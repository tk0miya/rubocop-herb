# Generated from lib/rubocop/herb/erb_parser/node_location_collector.rb with RBS::Inline

module RuboCop
  module Herb
    # Visitor that collects both ERB locations and HTML block positions in a single AST traversal.
    # Combines the functionality of ErbLocationCollector and HtmlBlockCollector.
    # Also collects HTML tags when html_visualization is enabled.
    class NodeLocationCollector < ::Herb::Visitor
      NODE_TYPE_MAP: untyped

      # Result of collecting node locations
      class Result < Data
        attr_reader erb_locations(): Hash[Integer, ErbLocation]

        attr_reader erb_max_columns(): Hash[Integer, Integer]

        attr_reader html_block_positions(): Set[::Herb::AST::HTMLElementNode]

        attr_reader tags(): Hash[Integer, Tag]

        def self.new: (Hash[Integer, ErbLocation] erb_locations, Hash[Integer, Integer] erb_max_columns, Set[::Herb::AST::HTMLElementNode] html_block_positions, Hash[Integer, Tag] tags) -> instance
                    | (erb_locations: Hash[Integer, ErbLocation], erb_max_columns: Hash[Integer, Integer], html_block_positions: Set[::Herb::AST::HTMLElementNode], tags: Hash[Integer, Tag]) -> instance

        def self.members: () -> [ :erb_locations, :erb_max_columns, :html_block_positions, :tags ]

        def members: () -> [ :erb_locations, :erb_max_columns, :html_block_positions, :tags ]
      end

      # Collect ERB locations, HTML block positions, and tags from a parse result
      # @rbs source: Source
      # @rbs ast: ::Herb::ParseResult
      # @rbs html_visualization: bool
      def self.collect: (Source source, ::Herb::ParseResult ast, ?html_visualization: bool) -> Result

      attr_reader source: Source

      attr_reader html_visualization: bool

      attr_reader erb_locations: Hash[Integer, ErbLocation]

      attr_reader erb_max_columns: Hash[Integer, Integer]

      attr_reader html_block_positions: Set[::Herb::AST::HTMLElementNode]

      attr_reader tags: Hash[Integer, Tag]

      # @rbs source: Source
      # @rbs html_visualization: bool
      def initialize: (source: Source, html_visualization: bool) -> void

      # @rbs node: ::Herb::AST::Node
      def visit_child_nodes: (::Herb::AST::Node node) -> void

      # Visit HTML element nodes and determine if they can be rendered as blocks.
      # Also collects tag info when html_visualization is enabled.
      # super is called first to traverse children and collect ERB locations,
      # then we check if this element qualifies as a block element.
      # Block positions are only collected when html_visualization is enabled,
      # otherwise TailExpressionCollector would incorrectly capture output nodes
      # inside HTML elements instead of the outer ERB control flow context.
      # @rbs node: ::Herb::AST::HTMLElementNode
      def visit_html_element_node: (::Herb::AST::HTMLElementNode node) -> void

      # Track when inside an HTML open tag for attribute/literal marker detection
      # Resets @open_tag_has_erb so only ERB within this open tag's children is considered
      # @rbs node: ::Herb::AST::HTMLOpenTagNode
      def visit_html_open_tag_node: (::Herb::AST::HTMLOpenTagNode node) -> void

      # Visit HTML text nodes and collect tag info when html_visualization is enabled
      # @rbs node: ::Herb::AST::HTMLTextNode
      def visit_html_text_node: (::Herb::AST::HTMLTextNode node) -> void

      # Visit HTML comment nodes and collect tag info when html_visualization is enabled
      # super is called first to traverse children and collect ERB locations,
      # then we check if this comment contains ERB to decide whether to record tag info.
      # Comments containing ERB are not recorded (they are visited normally to traverse children)
      # @rbs node: ::Herb::AST::HTMLCommentNode
      def visit_html_comment_node: (::Herb::AST::HTMLCommentNode node) -> void

      # Record static attributes inside open tags that contain ERB
      # When a whole attribute (e.g., class="foo") appears inside an ERB conditional within an open tag,
      # it needs to be recorded for hybrid_code restoration
      # @rbs node: ::Herb::AST::HTMLAttributeNode
      def visit_html_attribute_node: (::Herb::AST::HTMLAttributeNode node) -> void

      # Record literal text inside open tags that contain ERB
      # This captures static text in attribute values mixed with ERB (e.g., " world" in "<%= x %> world")
      # @rbs node: ::Herb::AST::LiteralNode
      def visit_literal_node: (::Herb::AST::LiteralNode node) -> void

      def visit_erb_block_node: (::Herb::AST::ERBBlockNode node) -> void

      def visit_erb_for_node: (::Herb::AST::ERBForNode node) -> void

      def visit_erb_while_node: (::Herb::AST::ERBWhileNode node) -> void

      def visit_erb_until_node: (::Herb::AST::ERBUntilNode node) -> void

      def visit_erb_if_node: (::Herb::AST::ERBIfNode node) -> void

      def visit_erb_unless_node: (::Herb::AST::ERBUnlessNode node) -> void

      def visit_erb_else_node: (::Herb::AST::ERBElseNode node) -> void

      def visit_erb_when_node: (::Herb::AST::ERBWhenNode node) -> void

      def visit_erb_begin_node: (::Herb::AST::ERBBeginNode node) -> void

      def visit_erb_rescue_node: (::Herb::AST::ERBRescueNode node) -> void

      def visit_erb_ensure_node: (::Herb::AST::ERBEnsureNode node) -> void

      def visit_erb_case_node: (::Herb::AST::ERBCaseNode node) -> void

      def visit_erb_yield_node: (::Herb::AST::ERBYieldNode node) -> void

      def visit_erb_end_node: (::Herb::AST::ERBEndNode node) -> void

      private

      # @rbs node: ::Herb::AST::Node
      def erb_node?: (::Herb::AST::Node node) -> bool

      # Record the location of an ERB node
      # @rbs node: erb_node
      def record_erb_location: (erb_node node) -> void

      # @rbs type: ErbLocation::erb_node_type
      # @rbs line: Integer
      # @rbs column: Integer
      def update_erb_max_columns: (ErbLocation::erb_node_type type, Integer line, Integer column) -> void

      # Determine the type of an ERB node
      # @rbs node: erb_node
      def determine_type: (erb_node node) -> ErbLocation::erb_node_type

      # Check if this HTML element can be rendered as a Ruby block
      # @rbs node: ::Herb::AST::HTMLElementNode
      def block_html_element?: (::Herb::AST::HTMLElementNode node) -> bool

      # Check if an HTML element contains ERB nodes
      # @rbs node: ::Herb::AST::HTMLElementNode
      def contains_erb?: (::Herb::AST::HTMLElementNode node) -> bool

      # Check if an HTML attribute contains ERB nodes
      # @rbs node: ::Herb::AST::HTMLAttributeNode
      def attribute_contains_erb?: (::Herb::AST::HTMLAttributeNode node) -> bool

      # Check if block notation fits within the open tag space
      # Block notation requires at least 3 bytes beyond tag name for " { "
      # @rbs node: ::Herb::AST::HTMLOpenTagNode
      def fits_block_notation?: (::Herb::AST::HTMLOpenTagNode node) -> bool

      # Record tag info for HTML elements
      # For elements with ERB: record open_tag (if it doesn't contain ERB) and close_tag
      # For elements without ERB: record the whole element
      # @rbs node: ::Herb::AST::HTMLElementNode
      def record_html_element_tag: (::Herb::AST::HTMLElementNode node) -> void

      # Record tag info for text nodes
      # Text nodes with multi-byte characters are skipped
      # @rbs node: ::Herb::AST::HTMLTextNode
      def record_text_node_tag: (::Herb::AST::HTMLTextNode node) -> void

      # Record tag info for HTML comments (without ERB)
      # Comments with multi-byte characters are skipped
      # @rbs node: ::Herb::AST::HTMLCommentNode
      def record_html_comment_tag: (::Herb::AST::HTMLCommentNode node) -> void

      # Record tag info for AST restoration
      # @rbs node: html_node
      def record_tag: (html_node node) -> void

      # Record tag info using location (for nodes without tag_opening/tag_closing)
      # @rbs node: ::Herb::AST::Node
      def record_location_tag: (::Herb::AST::Node node) -> void

      # Record tag info for a LiteralNode
      # Requires at least 3 characters to fit the "_x;" marker
      # @rbs node: ::Herb::AST::LiteralNode
      def record_literal_tag: (::Herb::AST::LiteralNode node) -> void

      # Check if text contains multi-byte characters
      # @rbs text: String
      def multibyte_chars?: (String text) -> bool
    end
  end
end
