# Generated from lib/rubocop/herb/ruby_renderer.rb with RBS::Inline

module RuboCop
  module Herb
    # Visitor-based renderer that traverses Herb AST and renders Ruby code.
    # Comments are collected during traversal and rendered at the end
    # with filtering applied.
    class RubyRenderer < ::Herb::Visitor
      include Characters

      # Result of rendering ERB source to Ruby code
      class Result < Data
        attr_reader source(): Source

        attr_reader code(): String

        attr_reader tags(): Hash[Integer, Tag]

        def self.new: (Source source, String code, Hash[Integer, Tag] tags) -> instance
                    | (source: Source, code: String, tags: Hash[Integer, Tag]) -> instance

        def self.members: () -> [ :source, :code, :tags ]

        def members: () -> [ :source, :code, :tags ]
      end

      # Render ERB source to Ruby code
      # @rbs source: Source
      # @rbs html_visualization: bool
      def self.render: (Source source, ?html_visualization: bool) -> Result

      attr_reader buffer: Array[Integer]

      attr_reader source: Source

      attr_reader result: Result

      attr_reader block_stack: Array[BlockContext]

      attr_reader comment_nodes: Array[::Herb::AST::Node]

      attr_reader code_positions: Hash[Integer, Integer]

      attr_reader close_tag_counter: Integer

      attr_reader html_visualization: bool

      attr_reader tags: Hash[Integer, Tag]

      # @rbs source: Source
      # @rbs html_visualization: bool
      def initialize: (Source source, ?html_visualization: bool) -> void

      # Override to render comments and build result after document traversal completes
      # @rbs node: ::Herb::AST::DocumentNode
      def visit_document_node: (::Herb::AST::DocumentNode node) -> void

      # Visit ERB block nodes (iterators like each, times, loop)
      # These are NOT control flow - return value is discarded
      # @rbs node: ::Herb::AST::ERBBlockNode
      def visit_erb_block_node: (::Herb::AST::ERBBlockNode node) -> void

      # Visit ERB for nodes (for loops - return value is discarded)
      # @rbs node: ::Herb::AST::ERBForNode
      def visit_erb_for_node: (::Herb::AST::ERBForNode node) -> void

      # Visit ERB while nodes (while loops - return value is discarded)
      # @rbs node: ::Herb::AST::ERBWhileNode
      def visit_erb_while_node: (::Herb::AST::ERBWhileNode node) -> void

      # Visit ERB until nodes (until loops - return value is discarded)
      # @rbs node: ::Herb::AST::ERBUntilNode
      def visit_erb_until_node: (::Herb::AST::ERBUntilNode node) -> void

      # Visit ERB if nodes (control flow - returns value)
      # @rbs node: ::Herb::AST::ERBIfNode
      def visit_erb_if_node: (::Herb::AST::ERBIfNode node) -> void

      # Visit ERB unless nodes (control flow - returns value)
      # @rbs node: ::Herb::AST::ERBUnlessNode
      def visit_erb_unless_node: (::Herb::AST::ERBUnlessNode node) -> void

      # Visit ERB else nodes (control flow continuation - returns value)
      # @rbs node: ::Herb::AST::ERBElseNode
      def visit_erb_else_node: (::Herb::AST::ERBElseNode node) -> void

      # Visit ERB case nodes (control flow - returns value)
      # @rbs node: ::Herb::AST::ERBCaseNode
      def visit_erb_case_node: (::Herb::AST::ERBCaseNode node) -> void

      # Visit ERB when nodes (control flow continuation - returns value)
      # @rbs node: ::Herb::AST::ERBWhenNode
      def visit_erb_when_node: (::Herb::AST::ERBWhenNode node) -> void

      # Visit ERB begin nodes (control flow - returns value)
      # @rbs node: ::Herb::AST::ERBBeginNode
      def visit_erb_begin_node: (::Herb::AST::ERBBeginNode node) -> void

      # Visit ERB rescue nodes (control flow - returns value)
      # @rbs node: ::Herb::AST::ERBRescueNode
      def visit_erb_rescue_node: (::Herb::AST::ERBRescueNode node) -> void

      # Visit ERB ensure nodes (control flow - returns value)
      # @rbs node: ::Herb::AST::ERBEnsureNode
      def visit_erb_ensure_node: (::Herb::AST::ERBEnsureNode node) -> void

      # Visit ERB content nodes (the actual Ruby code: <% %> or <%= %>)
      # @rbs node: ::Herb::AST::ERBContentNode
      def visit_erb_content_node: (::Herb::AST::ERBContentNode node) -> void

      # Visit ERB end nodes
      # @rbs node: ::Herb::AST::ERBEndNode
      def visit_erb_end_node: (::Herb::AST::ERBEndNode node) -> void

      # Visit HTML element nodes (container for open tag, content, and close tag)
      # If the element contains ERB nodes, renders open tag with semicolon/brace and processes children
      # If the element contains no ERB nodes, renders only the open tag name with full element range
      # @rbs node: ::Herb::AST::HTMLElementNode
      def visit_html_element_node: (::Herb::AST::HTMLElementNode node) -> void

      # Visit HTML text nodes (plain text content between tags)
      # Renders underscore at first non-whitespace position to indicate content presence
      # @rbs node: ::Herb::AST::HTMLTextNode
      def visit_html_text_node: (::Herb::AST::HTMLTextNode node) -> void

      private

      # @rbs statements: Array[::Herb::AST::Node]
      # @rbs returning_value: bool
      def push_block: (Array[::Herb::AST::Node] statements, ?returning_value: bool) -> void

      def pop_block: () -> void

      def current_block: () -> BlockContext?

      # @rbs node: ::Herb::AST::ERBContentNode
      def output_node?: (::Herb::AST::ERBContentNode node) -> bool

      # Check if this output node is a tail expression that doesn't need _ = marker
      # @rbs node: ::Herb::AST::ERBContentNode
      def tail_expression?: (::Herb::AST::ERBContentNode node) -> bool

      # @rbs node: ::Herb::AST::Node
      def render_code_node: (::Herb::AST::Node node) -> void

      # Record line and column for comment filtering (keep maximum column per line)
      # @rbs node: ::Herb::AST::Node
      def record_code_position: (::Herb::AST::Node node) -> void

      # @rbs node: ::Herb::AST::Node
      def render_output_marker: (::Herb::AST::Node node) -> void

      # Get the byte range of an HTML node
      # @rbs node: ::Herb::AST::HTMLElementNode | ::Herb::AST::HTMLTextNode | ::Herb::AST::HTMLOpenTagNode | ::Herb::AST::HTMLCloseTagNode
      def compute_node_range: (::Herb::AST::HTMLElementNode | ::Herb::AST::HTMLTextNode | ::Herb::AST::HTMLOpenTagNode | ::Herb::AST::HTMLCloseTagNode node) -> ::Herb::Range

      # Check if brace notation should be used for the given open tag
      # Brace notation requires at least 3 bytes beyond tag name for " { "
      # @rbs node: ::Herb::AST::HTMLOpenTagNode
      def use_brace_notation?: (::Herb::AST::HTMLOpenTagNode node) -> bool

      # Render HTML open tag as Ruby code
      # When as_brace is true, uses brace notation: "div { "
      # Otherwise, uses semicolon notation: "div; "
      # @rbs node: ::Herb::AST::HTMLOpenTagNode
      # @rbs as_brace: bool
      def render_open_tag_node: (::Herb::AST::HTMLOpenTagNode node, as_brace: bool) -> void

      # Render HTML close tag as Ruby code
      # When as_brace is true, renders "}" only
      # Otherwise, renders "tag0; " with counter to distinguish closing tags
      # @rbs node: ::Herb::AST::HTMLCloseTagNode
      # @rbs as_brace: bool
      def render_close_tag_node: (::Herb::AST::HTMLCloseTagNode node, as_brace: bool) -> void

      # Render HTML text node by placing "_; " at first non-whitespace position
      # This indicates content presence to avoid Lint/EmptyBlock and similar cops
      # Requires at least 3 bytes from the first non-whitespace position to end
      # @rbs node: ::Herb::AST::HTMLTextNode
      def render_text_node: (::Herb::AST::HTMLTextNode node) -> void

      # Render collected comments that can be safely converted to Ruby comments
      def render_comments: () -> void

      # Check if this comment can be rendered as a Ruby comment without breaking code
      # Comments are not renderable when there's code to the right on the same line,
      # because Ruby's # comment extends to end of line and would comment out the code
      # @rbs node: ::Herb::AST::ERBContentNode
      def renderable_comment?: (::Herb::AST::ERBContentNode node) -> bool

      # @rbs node: ::Herb::AST::ERBContentNode
      def render_comment_node: (::Herb::AST::ERBContentNode node) -> void

      # @rbs code: String
      # @rbs hash_column: Integer
      def format_multiline_comment: (String code, Integer hash_column) -> String

      # @rbs code: String
      def bleach_code: (String code) -> Array[Integer]

      # @rbs node: ::Herb::AST::Node
      def ruby_code_for: (::Herb::AST::Node node) -> String

      # Record tag info for AST restoration
      # @rbs node: ::Herb::AST::HTMLElementNode | ::Herb::AST::HTMLOpenTagNode | ::Herb::AST::HTMLCloseTagNode | ::Herb::AST::HTMLTextNode
      def record_tag_info: (::Herb::AST::HTMLElementNode | ::Herb::AST::HTMLOpenTagNode | ::Herb::AST::HTMLCloseTagNode | ::Herb::AST::HTMLTextNode node) -> void

      # Record ERB tag for AST restoration (without restoring source in hybrid code)
      # @rbs node: ::Herb::AST::Node
      def record_erb_tag: (::Herb::AST::Node node) -> void
    end
  end
end
