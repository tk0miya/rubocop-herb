# Generated from lib/rubocop/herb/ruby_renderer.rb with RBS::Inline

module RuboCop
  module Herb
    # Visitor-based renderer that traverses Herb AST and renders Ruby code.
    # Comments are retrieved from ParseResult and rendered at the end
    # with filtering applied.
    class RubyRenderer < ::Herb::Visitor
      extend Forwardable

      # Render ERB source to Ruby code
      # @rbs parse_result: ParseResult
      # @rbs html_visualization: bool
      def self.render: (ParseResult parse_result, ?html_visualization: bool) -> String

      attr_reader ruby_code: String

      attr_reader parse_result: ParseResult

      attr_reader tag_counter: Integer

      attr_reader html_visualization: bool

      def source: () -> Source

      def erb_locations: () -> Hash[Integer, ErbLocation]

      def erb_max_columns: () -> Hash[Integer, Integer]

      def erb_comment_nodes: () -> Array[::Herb::AST::ERBContentNode]

      def byteslice: (::Herb::Range) -> String

      def tail_expression?: (::Herb::AST::Node) -> bool

      # @rbs parse_result: ParseResult
      # @rbs html_visualization: bool
      def initialize: (ParseResult parse_result, ?html_visualization: bool) -> void

      # Override to render comments after document traversal completes
      # @rbs node: ::Herb::AST::DocumentNode
      def visit_document_node: (::Herb::AST::DocumentNode node) -> void

      def visit_erb_block_node: (::Herb::AST::ERBBlockNode node) -> void

      def visit_erb_for_node: (::Herb::AST::ERBForNode node) -> void

      def visit_erb_while_node: (::Herb::AST::ERBWhileNode node) -> void

      def visit_erb_until_node: (::Herb::AST::ERBUntilNode node) -> void

      def visit_erb_if_node: (::Herb::AST::ERBIfNode node) -> void

      def visit_erb_unless_node: (::Herb::AST::ERBUnlessNode node) -> void

      def visit_erb_else_node: (::Herb::AST::ERBElseNode node) -> void

      def visit_erb_when_node: (::Herb::AST::ERBWhenNode node) -> void

      def visit_erb_begin_node: (::Herb::AST::ERBBeginNode node) -> void

      def visit_erb_rescue_node: (::Herb::AST::ERBRescueNode node) -> void

      def visit_erb_ensure_node: (::Herb::AST::ERBEnsureNode node) -> void

      def visit_erb_case_node: (::Herb::AST::ERBCaseNode node) -> void

      def visit_erb_yield_node: (::Herb::AST::ERBYieldNode node) -> void

      def visit_erb_end_node: (::Herb::AST::ERBEndNode node) -> void

      # Visit ERB content nodes (the actual Ruby code: <% %> or <%= %>)
      # Comments are skipped here and rendered later via render_comments
      # Also sets @open_tag_has_erb when ERB content is found inside an open tag
      # @rbs node: ::Herb::AST::ERBContentNode
      def visit_erb_content_node: (::Herb::AST::ERBContentNode node) -> void

      # Visit HTML element nodes (container for open tag, content, and close tag)
      # If the element contains ERB nodes, renders open tag with semicolon/brace and processes children
      # If the element contains no ERB nodes, renders only the open tag name with full element range
      # @rbs node: ::Herb::AST::HTMLElementNode
      def visit_html_element_node: (::Herb::AST::HTMLElementNode node) -> void

      # Track when inside an HTML open tag for attribute/literal marker detection
      # Resets @open_tag_has_erb so only ERB within this open tag's children is considered
      # @rbs node: ::Herb::AST::HTMLOpenTagNode
      def visit_html_open_tag_node: (::Herb::AST::HTMLOpenTagNode node) -> void

      # Visit HTML text nodes (plain text content between tags)
      # Renders underscore at first non-whitespace position to indicate content presence
      # @rbs node: ::Herb::AST::HTMLTextNode
      def visit_html_text_node: (::Herb::AST::HTMLTextNode node) -> void

      # Visit HTML comment nodes (<!-- ... -->)
      # Comments containing ERB are processed normally (super visits children)
      # Pure HTML comments are rendered as "__;" to indicate content presence (like text nodes)
      # @rbs node: ::Herb::AST::HTMLCommentNode
      def visit_html_comment_node: (::Herb::AST::HTMLCommentNode node) -> void

      # Render markers for static attributes inside open tags that contain ERB
      # When a whole attribute (e.g., class="foo") appears inside an ERB conditional within an open tag,
      # it gets a marker to distinguish branches
      # @rbs node: ::Herb::AST::HTMLAttributeNode
      def visit_html_attribute_node: (::Herb::AST::HTMLAttributeNode node) -> void

      # Render markers for literal text inside open tags that contain ERB
      # This captures static text in attribute values mixed with ERB (e.g., " world" in "<%= x %> world")
      # @rbs node: ::Herb::AST::LiteralNode
      def visit_literal_node: (::Herb::AST::LiteralNode node) -> void

      private

      # @rbs node: ::Herb::AST::ERBContentNode
      def output_node?: (::Herb::AST::ERBContentNode node) -> bool

      # @rbs node: ::Herb::AST::Node
      def render_code_node: (::Herb::AST::Node node) -> void

      # Check if output node needs _ = marker
      # When html_visualization is disabled, always add marker to avoid Lint/Void false positives
      # When enabled, only add marker if not a tail expression
      # @rbs node: ::Herb::AST::Node
      def needs_output_marker?: (::Herb::AST::Node node) -> bool

      # @rbs node: ::Herb::AST::Node
      def render_output_marker: (::Herb::AST::Node node) -> void

      # Render HTML open tag as Ruby code
      # When as_brace is true, uses brace notation: "div { "
      # Otherwise, uses semicolon notation: "div; "
      # @rbs node: ::Herb::AST::HTMLOpenTagNode
      # @rbs as_brace: bool
      def render_open_tag_node: (::Herb::AST::HTMLOpenTagNode node, as_brace: bool) -> void

      # Render HTML close tag as Ruby code
      # When as_brace is true, renders "};" to ensure valid Ruby after block
      # Otherwise, renders "tagN; " with counter to distinguish closing tags
      # @rbs node: ::Herb::AST::HTMLCloseTagNode
      # @rbs as_brace: bool
      def render_close_tag_node: (::Herb::AST::HTMLCloseTagNode node, as_brace: bool) -> void

      # Render HTML text node by placing "_N;" at first non-whitespace position
      # This indicates content presence to avoid Lint/EmptyBlock and similar cops
      # Uses "_N" with counter to avoid false positives from Style/IdenticalConditionalBranches
      # Requires at least 4 characters from the first non-whitespace position to end
      # @rbs node: ::Herb::AST::HTMLTextNode
      def render_text_node: (::Herb::AST::HTMLTextNode node) -> void

      # Render collected comments that can be safely converted to Ruby comments
      def render_comments: () -> void

      # Check if this comment can be rendered as a Ruby comment without breaking code
      # Comments are not renderable when there's code to the right on the same line,
      # because Ruby's # comment extends to end of line and would comment out the code
      # @rbs node: ::Herb::AST::ERBContentNode
      def renderable_comment?: (::Herb::AST::ERBContentNode node) -> bool

      # @rbs node: ::Herb::AST::ERBContentNode
      def render_erb_comment_node: (::Herb::AST::ERBContentNode node) -> void

      # Render HTML comment as "_N;" to indicate content presence (like text nodes)
      # Places "_N;" at the start of the comment with counter
      # Uses "_N" with counter to avoid false positives from Style/IdenticalConditionalBranches
      # @rbs node: ::Herb::AST::HTMLCommentNode
      def render_html_comment_node: (::Herb::AST::HTMLCommentNode node) -> void

      # Render a marker for an HTML node at its start position using location
      # @rbs node: ::Herb::AST::Node
      def render_location_marker: (::Herb::AST::Node node) -> void

      # Render a marker for a LiteralNode at its start position
      # Requires at least 3 characters to fit the "_x;" marker
      # @rbs node: ::Herb::AST::LiteralNode
      def render_literal_marker: (::Herb::AST::LiteralNode node) -> void

      # Render tag marker "_x;" at the given position and increment counter
      # Uses alphabetic markers (_a, _b, ... _z) to avoid conflict with Ruby's numbered parameters (_1, _2, etc.)
      # @rbs pos: Integer -- character position in ruby_code
      def render_tag_marker: (Integer pos) -> void

      # Increment tag counter and return new value (cycles through 0-9)
      def next_tag_counter: () -> Integer

      # @rbs code: String
      # @rbs hash_column: Integer
      def format_multiline_comment: (String code, Integer hash_column) -> String

      # @rbs code: String
      def bleach_code: (String code) -> String

      # Convert byte position to character position
      # @rbs byte_pos: Integer
      def byte_to_char_pos: (Integer byte_pos) -> Integer

      # @rbs node: ::Herb::AST::Node
      def extract_ruby_code: (::Herb::AST::Node node) -> String

      # Check if an HTML node contains ERB
      # @rbs node: html_node
      def contains_erb?: (html_node node) -> bool

      # Check if an HTML node contains ERB using location-based range
      # @rbs node: ::Herb::AST::Node
      def contains_erb_location?: (::Herb::AST::Node node) -> bool
    end
  end
end
